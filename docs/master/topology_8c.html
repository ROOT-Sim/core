<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ROOT-Sim core: /home/runner/work/core/core/src/lib/topology/topology.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="flatdoc.css" rel="stylesheet" type="text/css"/>
<link href="inline-params.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="rs.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ROOT-Sim core
   &#160;<span id="projectnumber">3.0.0-rc.2</span>
   </div>
   <div id="projectbrief">A General-Purpose Multi-threaded Parallel/Distributed Simulation Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_c85d3e3c5052e9ad9ce18c6863244a25.html">lib</a></li><li class="navelem"><a class="el" href="dir_936721fd6a792737eaef7358bcd49428.html">topology</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">topology.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Topology library.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;assert.h&gt;</code><br />
<code>#include &lt;stdlib.h&gt;</code><br />
<code>#include &lt;<a class="el" href="core_8h_source.html">core/core.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="list_8h_source.html">datatypes/list.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="ROOT-Sim_8h_source.html">ROOT-Sim.h</a>&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for topology.c:</div>
<div class="dyncontent">
<div class="center"><img src="topology_8c__incl.png" border="0" usemap="#a_2home_2runner_2work_2core_2core_2src_2lib_2topology_2topology_8c" alt=""/></div>
<map name="a_2home_2runner_2work_2core_2core_2src_2lib_2topology_2topology_8c" id="a_2home_2runner_2work_2core_2core_2src_2lib_2topology_2topology_8c">
<area shape="rect" title="Topology library." alt="" coords="239,5,417,61"/>
<area shape="rect" title=" " alt="" coords="5,184,80,211"/>
<area shape="rect" title=" " alt="" coords="134,259,205,285"/>
<area shape="rect" href="core_8h.html" title="Core ROOT&#45;Sim functionalities." alt="" coords="482,109,577,136"/>
<area shape="rect" href="ROOT-Sim_8h.html" title="ROOT&#45;Sim header for model development." alt="" coords="366,184,466,211"/>
<area shape="rect" href="list_8h.html" title="List datatype." alt="" coords="147,109,269,136"/>
<area shape="rect" title=" " alt="" coords="514,259,577,285"/>
<area shape="rect" title=" " alt="" coords="601,259,671,285"/>
<area shape="rect" title=" " alt="" coords="696,259,779,285"/>
<area shape="rect" title=" " alt="" coords="419,259,490,285"/>
<area shape="rect" title=" " alt="" coords="320,259,395,285"/>
<area shape="rect" title=" " alt="" coords="229,259,296,285"/>
<area shape="rect" title=" " alt="" coords="203,184,290,211"/>
<area shape="rect" title=" " alt="" coords="104,184,179,211"/>
</map>
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph__node.html">graph_node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A node in the topology adjacency matrix.  <a href="structgraph__node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtopology.html">topology</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The structure describing a topology.  <a href="structtopology.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:acd37e9f03b1ffd22e22d05acadefba16"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="ROOT-Sim_8h.html#af291386e5adcb7f063e702f55eed01f4">lp_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="topology_8c.html#acd37e9f03b1ffd22e22d05acadefba16">get_random_neighbor</a> (<a class="el" href="ROOT-Sim_8h.html#af291386e5adcb7f063e702f55eed01f4">lp_id_t</a> from, struct <a class="el" href="structtopology.html">topology</a> *<a class="el" href="structtopology.html">topology</a>, size_t n_directions, enum <a class="el" href="ROOT-Sim_8h.html#abf956420f1ded9f4cf62902cb9e44756">topology_direction</a> directions[n_directions])</td></tr>
<tr class="memdesc:acd37e9f03b1ffd22e22d05acadefba16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a random neighbor.  <a href="topology_8c.html#acd37e9f03b1ffd22e22d05acadefba16">More...</a><br /></td></tr>
<tr class="separator:acd37e9f03b1ffd22e22d05acadefba16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a084a6470646e80177c648681111a5f2b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="ROOT-Sim_8h.html#af291386e5adcb7f063e702f55eed01f4">lp_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="topology_8c.html#a084a6470646e80177c648681111a5f2b">get_neighbor_hexagon</a> (<a class="el" href="ROOT-Sim_8h.html#af291386e5adcb7f063e702f55eed01f4">lp_id_t</a> from, struct <a class="el" href="structtopology.html">topology</a> *<a class="el" href="structtopology.html">topology</a>, enum <a class="el" href="ROOT-Sim_8h.html#abf956420f1ded9f4cf62902cb9e44756">topology_direction</a> direction)</td></tr>
<tr class="memdesc:a084a6470646e80177c648681111a5f2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a linear id in a TOPOLOGY_HEXAGON map, get the linear id of a neighbor in a given direction (if any).  <a href="topology_8c.html#a084a6470646e80177c648681111a5f2b">More...</a><br /></td></tr>
<tr class="separator:a084a6470646e80177c648681111a5f2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac59c7485cbd413020cb4fd2789f6ca95"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="ROOT-Sim_8h.html#af291386e5adcb7f063e702f55eed01f4">lp_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="topology_8c.html#ac59c7485cbd413020cb4fd2789f6ca95">get_neighbor_square</a> (<a class="el" href="ROOT-Sim_8h.html#af291386e5adcb7f063e702f55eed01f4">lp_id_t</a> from, struct <a class="el" href="structtopology.html">topology</a> *<a class="el" href="structtopology.html">topology</a>, enum <a class="el" href="ROOT-Sim_8h.html#abf956420f1ded9f4cf62902cb9e44756">topology_direction</a> direction)</td></tr>
<tr class="memdesc:ac59c7485cbd413020cb4fd2789f6ca95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a linear id in a TOPOLOGY_SQUARE map, get the linear id of a neighbor in a given direction (if any).  <a href="topology_8c.html#ac59c7485cbd413020cb4fd2789f6ca95">More...</a><br /></td></tr>
<tr class="separator:ac59c7485cbd413020cb4fd2789f6ca95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d2e8bdfd17fa983d539e1142e0dd122"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="ROOT-Sim_8h.html#af291386e5adcb7f063e702f55eed01f4">lp_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="topology_8c.html#a0d2e8bdfd17fa983d539e1142e0dd122">get_neighbor_torus</a> (<a class="el" href="ROOT-Sim_8h.html#af291386e5adcb7f063e702f55eed01f4">lp_id_t</a> from, struct <a class="el" href="structtopology.html">topology</a> *<a class="el" href="structtopology.html">topology</a>, enum <a class="el" href="ROOT-Sim_8h.html#abf956420f1ded9f4cf62902cb9e44756">topology_direction</a> direction)</td></tr>
<tr class="memdesc:a0d2e8bdfd17fa983d539e1142e0dd122"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a linear id in a TOPOLOGY_TORUS map, get the linear id of a neighbor in a given direction (if any).  <a href="topology_8c.html#a0d2e8bdfd17fa983d539e1142e0dd122">More...</a><br /></td></tr>
<tr class="separator:a0d2e8bdfd17fa983d539e1142e0dd122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae62406bafec543dbccf69c437ef8008d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="ROOT-Sim_8h.html#af291386e5adcb7f063e702f55eed01f4">lp_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="topology_8c.html#ae62406bafec543dbccf69c437ef8008d">get_neighbor_mesh</a> (<a class="el" href="ROOT-Sim_8h.html#af291386e5adcb7f063e702f55eed01f4">lp_id_t</a> from, struct <a class="el" href="structtopology.html">topology</a> *<a class="el" href="structtopology.html">topology</a>, enum <a class="el" href="ROOT-Sim_8h.html#abf956420f1ded9f4cf62902cb9e44756">topology_direction</a> direction)</td></tr>
<tr class="memdesc:ae62406bafec543dbccf69c437ef8008d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an id in a TOPOLOGY_FCMESH map, get the id of a neighbor.  <a href="topology_8c.html#ae62406bafec543dbccf69c437ef8008d">More...</a><br /></td></tr>
<tr class="separator:ae62406bafec543dbccf69c437ef8008d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abde7a4a157b826db5e7b18f265df93e5"><td class="memItemLeft" align="right" valign="top"><a id="abde7a4a157b826db5e7b18f265df93e5"></a>
static <a class="el" href="ROOT-Sim_8h.html#af291386e5adcb7f063e702f55eed01f4">lp_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_neighbor_bidring</b> (<a class="el" href="ROOT-Sim_8h.html#af291386e5adcb7f063e702f55eed01f4">lp_id_t</a> from, struct <a class="el" href="structtopology.html">topology</a> *<a class="el" href="structtopology.html">topology</a>, enum <a class="el" href="ROOT-Sim_8h.html#abf956420f1ded9f4cf62902cb9e44756">topology_direction</a> direction)</td></tr>
<tr class="separator:abde7a4a157b826db5e7b18f265df93e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8a5c75c23c9fff68630c77e4e3ccc6c"><td class="memItemLeft" align="right" valign="top"><a id="af8a5c75c23c9fff68630c77e4e3ccc6c"></a>
static <a class="el" href="ROOT-Sim_8h.html#af291386e5adcb7f063e702f55eed01f4">lp_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_neighbor_ring</b> (<a class="el" href="ROOT-Sim_8h.html#af291386e5adcb7f063e702f55eed01f4">lp_id_t</a> from, struct <a class="el" href="structtopology.html">topology</a> *<a class="el" href="structtopology.html">topology</a>, enum <a class="el" href="ROOT-Sim_8h.html#abf956420f1ded9f4cf62902cb9e44756">topology_direction</a> direction)</td></tr>
<tr class="separator:af8a5c75c23c9fff68630c77e4e3ccc6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66ebe373cc86dba54b7b12a2e4ec54d1"><td class="memItemLeft" align="right" valign="top"><a id="a66ebe373cc86dba54b7b12a2e4ec54d1"></a>
static <a class="el" href="ROOT-Sim_8h.html#af291386e5adcb7f063e702f55eed01f4">lp_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_neighbor_star</b> (<a class="el" href="ROOT-Sim_8h.html#af291386e5adcb7f063e702f55eed01f4">lp_id_t</a> from, struct <a class="el" href="structtopology.html">topology</a> *<a class="el" href="structtopology.html">topology</a>, enum <a class="el" href="ROOT-Sim_8h.html#abf956420f1ded9f4cf62902cb9e44756">topology_direction</a> direction)</td></tr>
<tr class="separator:a66ebe373cc86dba54b7b12a2e4ec54d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1e6ee0e2dfdcb74cf254a61290ea2a0"><td class="memItemLeft" align="right" valign="top"><a id="af1e6ee0e2dfdcb74cf254a61290ea2a0"></a>
static <a class="el" href="ROOT-Sim_8h.html#af291386e5adcb7f063e702f55eed01f4">lp_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_neighbor_graph</b> (<a class="el" href="ROOT-Sim_8h.html#af291386e5adcb7f063e702f55eed01f4">lp_id_t</a> from, struct <a class="el" href="structtopology.html">topology</a> *<a class="el" href="structtopology.html">topology</a>, enum <a class="el" href="ROOT-Sim_8h.html#abf956420f1ded9f4cf62902cb9e44756">topology_direction</a> direction)</td></tr>
<tr class="separator:af1e6ee0e2dfdcb74cf254a61290ea2a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa41edd50a19ed595b14c3320c66d22d6"><td class="memItemLeft" align="right" valign="top"><a id="aa41edd50a19ed595b14c3320c66d22d6"></a>
<a class="el" href="ROOT-Sim_8h.html#af291386e5adcb7f063e702f55eed01f4">lp_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>CountRegions</b> (struct <a class="el" href="structtopology.html">topology</a> *<a class="el" href="structtopology.html">topology</a>)</td></tr>
<tr class="separator:aa41edd50a19ed595b14c3320c66d22d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8f9c07e1e15ca33e5f4edd8e99c1926"><td class="memItemLeft" align="right" valign="top"><a id="ab8f9c07e1e15ca33e5f4edd8e99c1926"></a>
<a class="el" href="ROOT-Sim_8h.html#af291386e5adcb7f063e702f55eed01f4">lp_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>CountDirections</b> (<a class="el" href="ROOT-Sim_8h.html#af291386e5adcb7f063e702f55eed01f4">lp_id_t</a> from, struct <a class="el" href="structtopology.html">topology</a> *<a class="el" href="structtopology.html">topology</a>)</td></tr>
<tr class="separator:ab8f9c07e1e15ca33e5f4edd8e99c1926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4db4c2402531b0fe531a8ac10e1e951a"><td class="memItemLeft" align="right" valign="top"><a id="a4db4c2402531b0fe531a8ac10e1e951a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsNeighbor</b> (<a class="el" href="ROOT-Sim_8h.html#af291386e5adcb7f063e702f55eed01f4">lp_id_t</a> from, <a class="el" href="ROOT-Sim_8h.html#af291386e5adcb7f063e702f55eed01f4">lp_id_t</a> to, struct <a class="el" href="structtopology.html">topology</a> *<a class="el" href="structtopology.html">topology</a>)</td></tr>
<tr class="separator:a4db4c2402531b0fe531a8ac10e1e951a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14da6c63b741fa227b50865c3f39605e"><td class="memItemLeft" align="right" valign="top"><a id="a14da6c63b741fa227b50865c3f39605e"></a>
<a class="el" href="ROOT-Sim_8h.html#af291386e5adcb7f063e702f55eed01f4">lp_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>GetReceiver</b> (<a class="el" href="ROOT-Sim_8h.html#af291386e5adcb7f063e702f55eed01f4">lp_id_t</a> from, struct <a class="el" href="structtopology.html">topology</a> *<a class="el" href="structtopology.html">topology</a>, enum <a class="el" href="ROOT-Sim_8h.html#abf956420f1ded9f4cf62902cb9e44756">topology_direction</a> direction)</td></tr>
<tr class="separator:a14da6c63b741fa227b50865c3f39605e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afffbbee669753a386d22672af6e2fd58"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structtopology.html">topology</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="topology_8c.html#afffbbee669753a386d22672af6e2fd58">vInitializeTopology</a> (enum <a class="el" href="ROOT-Sim_8h.html#a49cb922df95ca5c0b7ef2d32568e00ab">topology_geometry</a> geometry, int argc,...)</td></tr>
<tr class="memdesc:afffbbee669753a386d22672af6e2fd58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a topology region.  <a href="topology_8c.html#afffbbee669753a386d22672af6e2fd58">More...</a><br /></td></tr>
<tr class="separator:afffbbee669753a386d22672af6e2fd58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cec4ceb346f45cc2b7f9a423680307a"><td class="memItemLeft" align="right" valign="top"><a id="a7cec4ceb346f45cc2b7f9a423680307a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ReleaseTopology</b> (struct <a class="el" href="structtopology.html">topology</a> *<a class="el" href="structtopology.html">topology</a>)</td></tr>
<tr class="separator:a7cec4ceb346f45cc2b7f9a423680307a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5df6581ce7144666cd6005d71e8c6fb"><td class="memItemLeft" align="right" valign="top"><a id="ad5df6581ce7144666cd6005d71e8c6fb"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>AddTopologyLink</b> (struct <a class="el" href="structtopology.html">topology</a> *<a class="el" href="structtopology.html">topology</a>, <a class="el" href="ROOT-Sim_8h.html#af291386e5adcb7f063e702f55eed01f4">lp_id_t</a> from, <a class="el" href="ROOT-Sim_8h.html#af291386e5adcb7f063e702f55eed01f4">lp_id_t</a> to, double probability)</td></tr>
<tr class="separator:ad5df6581ce7144666cd6005d71e8c6fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a9bb25ea2bd8b9f7f591b480c343d4877"><td class="memItemLeft" align="right" valign="top">static enum <a class="el" href="ROOT-Sim_8h.html#abf956420f1ded9f4cf62902cb9e44756">topology_direction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="topology_8c.html#a9bb25ea2bd8b9f7f591b480c343d4877">directions_hexagon</a> []</td></tr>
<tr class="memdesc:a9bb25ea2bd8b9f7f591b480c343d4877"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allowed directions to reach a neighbor in a TOPOLOGY_HEXAGON.  <a href="topology_8c.html#a9bb25ea2bd8b9f7f591b480c343d4877">More...</a><br /></td></tr>
<tr class="separator:a9bb25ea2bd8b9f7f591b480c343d4877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1caeae311e8436eeb4473e08d5f4558c"><td class="memItemLeft" align="right" valign="top"><a id="a1caeae311e8436eeb4473e08d5f4558c"></a>
static enum <a class="el" href="ROOT-Sim_8h.html#abf956420f1ded9f4cf62902cb9e44756">topology_direction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="topology_8c.html#a1caeae311e8436eeb4473e08d5f4558c">directions_square_torus</a> [] = {<a class="el" href="ROOT-Sim_8h.html#abf956420f1ded9f4cf62902cb9e44756a91218ad3b3a944f722b5c451fe23a962">DIRECTION_E</a>, <a class="el" href="ROOT-Sim_8h.html#abf956420f1ded9f4cf62902cb9e44756a91c80c8d0494916dffbd47f13ef09741">DIRECTION_W</a>, <a class="el" href="ROOT-Sim_8h.html#abf956420f1ded9f4cf62902cb9e44756a0b6d647eb18d4e6c1af7ffd6e2f6e83c">DIRECTION_N</a>, <a class="el" href="ROOT-Sim_8h.html#abf956420f1ded9f4cf62902cb9e44756adae837b770c77c494259db1e438f1823">DIRECTION_S</a>}</td></tr>
<tr class="memdesc:a1caeae311e8436eeb4473e08d5f4558c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allowed directions to reach a neighbor in either a TOPOLOGY_SQUARE or a TOPOLOGY_TORUS. <br /></td></tr>
<tr class="separator:a1caeae311e8436eeb4473e08d5f4558c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Topology library. </p>
<p>A library implementing commonly-required topologies in simulation models.</p>
<dl class="section copyright"><dt>Copyright</dt><dd>Copyright (C) 2008-2022 HPDCS Group <a href="https://hpdcs.github.io">https://hpdcs.github.io</a> </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a084a6470646e80177c648681111a5f2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a084a6470646e80177c648681111a5f2b">&#9670;&nbsp;</a></span>get_neighbor_hexagon()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="ROOT-Sim_8h.html#af291386e5adcb7f063e702f55eed01f4">lp_id_t</a> get_neighbor_hexagon </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ROOT-Sim_8h.html#af291386e5adcb7f063e702f55eed01f4">lp_id_t</a>&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structtopology.html">topology</a> *&#160;</td>
          <td class="paramname"><em>topology</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="ROOT-Sim_8h.html#abf956420f1ded9f4cf62902cb9e44756">topology_direction</a>&#160;</td>
          <td class="paramname"><em>direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a linear id in a TOPOLOGY_HEXAGON map, get the linear id of a neighbor in a given direction (if any). </p>
<p>We use only one possible representation of a hexagonal map, namely a "pointy" "odd-r" horizontal layout, with an arbitrary width and height. In this representation, odd rows are showed right:</p>
<p>/ \ / \ / \ / \ |0,0|1,0|2,0|3,0| \ / \ / \ / \ / \ |0,1|1,1|2,1|3,1| / \ / \ / \ / \ / |0,2|1,2|2,2|3,2| \ / \ / \ / \ /</p>
<p>This is a map of size 3x4, in which 12 different cells are represented. In each hexagon, the (x,y) coordinates are represented. Nevertheless, to support simulation, we typically linearize the cells of the map. Indeed, the cells are linearly mapped as: 0 → (0,0); 1 → (1,0); 2 → (2,0); 3 → (3,0); 4 → (0,1); 5 → (1,1); 6 → (2,1); 7 → (3,1); etc.</p>
<p>The general mapping from linear (L) to hex (x,y) is therefore implemented as (in integer arithmetic): y = L / width x = L % width</p>
<p>while the mapping from (x,y) to L is implemented as:</p>
<p>L = y * width + x</p>
<p>When checking for a neighbor, we have to consider the row in which we are starting from. Indeed, considering that it's an "odd-r" map, if we are in an odd row and we move "up left" or "down left", we retain the same x value. Conversely, if we move from an odd row "up right" or "down right", we have to increment x. Moving from an even row is the other way round (retain x if you move up/down right, decrement if you move up/down left). In this implementation, we use bitwise and with 1 to check if we are in an odd row. Moving up/down always decrements/increments y. Moving right/left only increments/decrements x.</p>
<p>At the end, to check if a move is valid, we compare new coordinates (x,y) with the size of the grid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>The linear representation of the source element </td></tr>
    <tr><td class="paramname">topology</td><td>The structure keeping the information about the topology </td></tr>
    <tr><td class="paramname">direction</td><td>The direction to move towards, to find a linear id </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The linear id of the neighbor, INVALID_DIRECTION if such neighbor does not exist in the topology. </dd></dl>

</div>
</div>
<a id="ae62406bafec543dbccf69c437ef8008d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae62406bafec543dbccf69c437ef8008d">&#9670;&nbsp;</a></span>get_neighbor_mesh()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="ROOT-Sim_8h.html#af291386e5adcb7f063e702f55eed01f4">lp_id_t</a> get_neighbor_mesh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ROOT-Sim_8h.html#af291386e5adcb7f063e702f55eed01f4">lp_id_t</a>&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structtopology.html">topology</a> *&#160;</td>
          <td class="paramname"><em>topology</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="ROOT-Sim_8h.html#abf956420f1ded9f4cf62902cb9e44756">topology_direction</a>&#160;</td>
          <td class="paramname"><em>direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an id in a TOPOLOGY_FCMESH map, get the id of a neighbor. </p>
<p>The algorithm is simple: return a random element in the topology, different from from. The only corner case is if we have only one element, in which case we return INVALID_DIRECTION.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>The linear representation of the source element </td></tr>
    <tr><td class="paramname">topology</td><td>The structure keeping the information about the topology </td></tr>
    <tr><td class="paramname">direction</td><td>Can be only set to DIRECTION_RANDOM </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The linear id of the neighbor, INVALID_DIRECTION if such neighbor does not exist in the topology. </dd></dl>

</div>
</div>
<a id="ac59c7485cbd413020cb4fd2789f6ca95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac59c7485cbd413020cb4fd2789f6ca95">&#9670;&nbsp;</a></span>get_neighbor_square()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="ROOT-Sim_8h.html#af291386e5adcb7f063e702f55eed01f4">lp_id_t</a> get_neighbor_square </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ROOT-Sim_8h.html#af291386e5adcb7f063e702f55eed01f4">lp_id_t</a>&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structtopology.html">topology</a> *&#160;</td>
          <td class="paramname"><em>topology</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="ROOT-Sim_8h.html#abf956420f1ded9f4cf62902cb9e44756">topology_direction</a>&#160;</td>
          <td class="paramname"><em>direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a linear id in a TOPOLOGY_SQUARE map, get the linear id of a neighbor in a given direction (if any). </p>
<p>The general mapping from linear (L) to hex (x,y) is therefore implemented as (in integer arithmetic): y = L / width x = L % width</p>
<p>while the mapping from (x,y) to L is implemented as: L = y * width + x</p>
<p>Getting a neighbor simply entails incrementing/decrementing x or y, depending on the direction, and then checking if such an element exists in the current map.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>The linear representation of the source element </td></tr>
    <tr><td class="paramname">topology</td><td>The structure keeping the information about the topology </td></tr>
    <tr><td class="paramname">direction</td><td>The direction to move towards, to find a linear id </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The linear id of the neighbor, INVALID_DIRECTION if such neighbor does not exist in the topology. </dd></dl>

</div>
</div>
<a id="a0d2e8bdfd17fa983d539e1142e0dd122"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d2e8bdfd17fa983d539e1142e0dd122">&#9670;&nbsp;</a></span>get_neighbor_torus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="ROOT-Sim_8h.html#af291386e5adcb7f063e702f55eed01f4">lp_id_t</a> get_neighbor_torus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ROOT-Sim_8h.html#af291386e5adcb7f063e702f55eed01f4">lp_id_t</a>&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structtopology.html">topology</a> *&#160;</td>
          <td class="paramname"><em>topology</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="ROOT-Sim_8h.html#abf956420f1ded9f4cf62902cb9e44756">topology_direction</a>&#160;</td>
          <td class="paramname"><em>direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a linear id in a TOPOLOGY_TORUS map, get the linear id of a neighbor in a given direction (if any). </p>
<p>The general mapping from linear (L) to hex (x,y) is therefore implemented as (in integer arithmetic): y = L / width x = L % width</p>
<p>while the mapping from (x,y) to L is implemented as: L = y * width + x</p>
<p>Getting a neighbor simply entails incrementing/decrementing x or y, depending on the direction, and computing the modulus on the map size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>The linear representation of the source element </td></tr>
    <tr><td class="paramname">topology</td><td>The structure keeping the information about the topology </td></tr>
    <tr><td class="paramname">direction</td><td>The direction to move towards, to find a linear id </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The linear id of the neighbor, which always exists. </dd></dl>

</div>
</div>
<a id="acd37e9f03b1ffd22e22d05acadefba16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd37e9f03b1ffd22e22d05acadefba16">&#9670;&nbsp;</a></span>get_random_neighbor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="ROOT-Sim_8h.html#af291386e5adcb7f063e702f55eed01f4">lp_id_t</a> get_random_neighbor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ROOT-Sim_8h.html#af291386e5adcb7f063e702f55eed01f4">lp_id_t</a>&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structtopology.html">topology</a> *&#160;</td>
          <td class="paramname"><em>topology</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n_directions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="ROOT-Sim_8h.html#abf956420f1ded9f4cf62902cb9e44756">topology_direction</a>&#160;</td>
          <td class="paramname"><em>directions</em>[n_directions]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a random neighbor. </p>
<p>This function computes a random receiver, only for TOPOLOGY_HEXAGON, TOPOLOGY_SQUARE, and TOPOLOGY_TORUS. The algorithm simply generates a random permutation over the list of valid directions passed by the caller, and then attempts to get a receiver in every direction. The first direction that is not INVALID_DIRECTION dictates the picked random neighbor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>source element of the random receiver computation </td></tr>
    <tr><td class="paramname">topology</td><td>the topology currently being considered </td></tr>
    <tr><td class="paramname">n_directions</td><td>the number of valid directions for the given topology </td></tr>
    <tr><td class="paramname">directions</td><td>the number of directions (a variable array)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A random neighbor according to the specified topology </dd></dl>

</div>
</div>
<a id="afffbbee669753a386d22672af6e2fd58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afffbbee669753a386d22672af6e2fd58">&#9670;&nbsp;</a></span>vInitializeTopology()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structtopology.html">topology</a>* vInitializeTopology </td>
          <td>(</td>
          <td class="paramtype">enum <a class="el" href="ROOT-Sim_8h.html#a49cb922df95ca5c0b7ef2d32568e00ab">topology_geometry</a>&#160;</td>
          <td class="paramname"><em>geometry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a topology region. </p>
<p>This is a variadic function, that initializes a topology depending on its actual shape. In case the topology is a grid, two unsigned parameters should be passed, to specify the width and height of the grid. For all other topologies (included generic graphs) only a single unsigned parameter is needed, which is the number of elements composing the topology.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">geometry</td><td>The geometry to be used in the topology, a value from enum topology_geometry </td></tr>
    <tr><td class="paramname">argc</td><td>This is the number of variadic arguments passed to the function, computed thanks to some preprocessor black magic. This allows to make some early sanity check and prevent users to mess with the stack or initialize wrong topologies. </td></tr>
    <tr><td class="paramname">...</td><td>If geometry is TOPOLOGY_HEXAGON, TOPOLOGY_SQUARE, or TOPOLOGY_TORUS, two unsigned should be passed, to specify the width and height of the topology's grid. For all the other topologies, a single unsigned, determining the number of elements that compose the topology should be passed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to as newly-allocated opaque topology struct. Releasing the topology (and all the memory internally used to represent it) can be done by passing it to ReleaseTopology(). </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a9bb25ea2bd8b9f7f591b480c343d4877"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bb25ea2bd8b9f7f591b480c343d4877">&#9670;&nbsp;</a></span>directions_hexagon</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="ROOT-Sim_8h.html#abf956420f1ded9f4cf62902cb9e44756">topology_direction</a> directions_hexagon[]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {<a class="code" href="ROOT-Sim_8h.html#abf956420f1ded9f4cf62902cb9e44756a91218ad3b3a944f722b5c451fe23a962">DIRECTION_E</a>, <a class="code" href="ROOT-Sim_8h.html#abf956420f1ded9f4cf62902cb9e44756a91c80c8d0494916dffbd47f13ef09741">DIRECTION_W</a>, <a class="code" href="ROOT-Sim_8h.html#abf956420f1ded9f4cf62902cb9e44756a1713f8a1df33423392a89f25feecf543">DIRECTION_NE</a>, <a class="code" href="ROOT-Sim_8h.html#abf956420f1ded9f4cf62902cb9e44756aa325e54a21a7045dee61a0c27f7469fd">DIRECTION_NW</a>,</div>
<div class="line">    <a class="code" href="ROOT-Sim_8h.html#abf956420f1ded9f4cf62902cb9e44756a81b87f633155896c78ea5db8e0f95614">DIRECTION_SE</a>, <a class="code" href="ROOT-Sim_8h.html#abf956420f1ded9f4cf62902cb9e44756a3d4ce910c2cc3c5409ddcb30bb3238b8">DIRECTION_SW</a>}</div>
<div class="ttc" id="aROOT-Sim_8h_html_abf956420f1ded9f4cf62902cb9e44756a1713f8a1df33423392a89f25feecf543"><div class="ttname"><a href="ROOT-Sim_8h.html#abf956420f1ded9f4cf62902cb9e44756a1713f8a1df33423392a89f25feecf543">DIRECTION_NE</a></div><div class="ttdeci">@ DIRECTION_NE</div><div class="ttdoc">North-east direction.</div><div class="ttdef"><b>Definition:</b> ROOT-Sim.h:136</div></div>
<div class="ttc" id="aROOT-Sim_8h_html_abf956420f1ded9f4cf62902cb9e44756a3d4ce910c2cc3c5409ddcb30bb3238b8"><div class="ttname"><a href="ROOT-Sim_8h.html#abf956420f1ded9f4cf62902cb9e44756a3d4ce910c2cc3c5409ddcb30bb3238b8">DIRECTION_SW</a></div><div class="ttdeci">@ DIRECTION_SW</div><div class="ttdoc">South-west direction.</div><div class="ttdef"><b>Definition:</b> ROOT-Sim.h:137</div></div>
<div class="ttc" id="aROOT-Sim_8h_html_abf956420f1ded9f4cf62902cb9e44756a81b87f633155896c78ea5db8e0f95614"><div class="ttname"><a href="ROOT-Sim_8h.html#abf956420f1ded9f4cf62902cb9e44756a81b87f633155896c78ea5db8e0f95614">DIRECTION_SE</a></div><div class="ttdeci">@ DIRECTION_SE</div><div class="ttdoc">South-east direction.</div><div class="ttdef"><b>Definition:</b> ROOT-Sim.h:139</div></div>
<div class="ttc" id="aROOT-Sim_8h_html_abf956420f1ded9f4cf62902cb9e44756a91218ad3b3a944f722b5c451fe23a962"><div class="ttname"><a href="ROOT-Sim_8h.html#abf956420f1ded9f4cf62902cb9e44756a91218ad3b3a944f722b5c451fe23a962">DIRECTION_E</a></div><div class="ttdeci">@ DIRECTION_E</div><div class="ttdoc">East direction.</div><div class="ttdef"><b>Definition:</b> ROOT-Sim.h:132</div></div>
<div class="ttc" id="aROOT-Sim_8h_html_abf956420f1ded9f4cf62902cb9e44756a91c80c8d0494916dffbd47f13ef09741"><div class="ttname"><a href="ROOT-Sim_8h.html#abf956420f1ded9f4cf62902cb9e44756a91c80c8d0494916dffbd47f13ef09741">DIRECTION_W</a></div><div class="ttdeci">@ DIRECTION_W</div><div class="ttdoc">West direction.</div><div class="ttdef"><b>Definition:</b> ROOT-Sim.h:133</div></div>
<div class="ttc" id="aROOT-Sim_8h_html_abf956420f1ded9f4cf62902cb9e44756aa325e54a21a7045dee61a0c27f7469fd"><div class="ttname"><a href="ROOT-Sim_8h.html#abf956420f1ded9f4cf62902cb9e44756aa325e54a21a7045dee61a0c27f7469fd">DIRECTION_NW</a></div><div class="ttdeci">@ DIRECTION_NW</div><div class="ttdoc">North-west direction.</div><div class="ttdef"><b>Definition:</b> ROOT-Sim.h:138</div></div>
</div><!-- fragment -->
<p>Allowed directions to reach a neighbor in a TOPOLOGY_HEXAGON. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
